package partice;

/**
 * @author chengj
 * @Description 1493.删掉一个元素以后全为 1 的最长子数组 中等
 * @Date 2022/8/24
 */
//给你一个二进制数组 nums ，你需要从中删掉一个元素。
//
// 请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。
//
// 如果不存在这样的子数组，请返回 0 。
//
//
//
// 提示 1：
//
//
//输入：nums = [1,1,0,1]
//输出：3
//解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。
//
// 示例 2：
//
//
//输入：nums = [0,1,1,1,0,1,1,0,1]
//输出：5
//解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。
//
// 示例 3：
//
//
//输入：nums = [1,1,1]
//输出：2
//解释：你必须要删除一个元素。
//
//
//
// 提示：
//
//
// 1 <= nums.length <= 10⁵
// nums[i] 要么是 0 要么是 1 。
//
// Related Topics 数组 动态规划 滑动窗口 👍 64 👎 0
public class LongestSubarray {

    /**
     * 滑动窗口解法
     * @param nums
     * @return
     */
    public int longestSubarray(int[] nums) {

        // count 用来记录窗口内0的个数
        int l=0,r=0,count=0,n=nums.length;
        int res=0;
        while( r < n ){
            // 更新窗口内0的个数
            if(nums[r] == 0){
                count++;
            }

            // 当窗口内0的个数超过1个时，则需要收缩左边界来保证窗口内0的个数不超过1
            while(count > 1){
                if(nums[l++] == 0){
                    count--;
                }
            }
            // 当窗口内 0 的个数小于等于一个时，我们统计窗口内可被1替换0后的长度
            res = Math.max(res,r-l+1);
            r++;
        }
        // 由于窗口长度为替换一个0后最长连续1的长度，因此减掉1后为 删除一个0 的最长长度了
        return res-1;
    }
}
